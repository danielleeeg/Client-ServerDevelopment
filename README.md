# Client-ServerDevelopment

To write programs that are maintainable, readable, and adaptable, it is important to use clear, descriptive naming conventions, modularize code, document code, and keep the code a s simple as possible. Using clear and descriptive naming conventions makes the program easier to follow and requires collaborators to take less time reading comments and documentation as a barrier to entry for understanding the program. Modularizing code allows developers to make online modifications to the program without needed to take the whole site down. It also makes it easier to reuse sections of code for various purposes, simplifying the program and reducing the sheer amount of code required. Documenting code is important for improving readability and conveying ideas and purpose in a plain language or diagram format. This can save a ton of time when code is shared among many collaborators, or even when it is a program that the original developer themselves will need to return to to modify. Less assumptions need to be made when modifying a well-documented program with well-defined naming conventions. 

In writing the CRUD module, it was important to make all methods have a very descriptive, yet simple name (create, read, update, and delete). Each variable name clearly and simply describes what its purpose is. The balance between simplicity and descriptiveness is important. While each function could have been simplified, say, the function names were c, r, u, and d, these names lack detail on what their purpose is. Alternatively, they could have been more descriptive, say they were named create_a_new_animal_document, read_an_animal_document, etc. Although the more descriptive names may give a bit more information on function purpose, the loss of simplicity can make the module more difficult to use. The modularity of this module also makes it accessible to use with databases aside from aac. Since the CRUD object’s initialization required a database, collection, and host name, it can be reused to interact with other MongoDB applications.  

As a computer scientist, I approach a project such as this one for Grazioso Salvare through the lens of the SDLC. First, I review all requirements to determine the scope and desired end product from the client. Then, I work on design by figuring out any process models, how data should flow, what integrations are needed, and so on. Being a student, I then work on learning more about any item I do not fully understand. Next, I work on development. In the case of this project, I started by developing the CRUD module before moving on to dashboard development. I tend to do some amount of testing each step of the way, but I do spend some dedicated time testing the final system as well. Next, the ‘deployment and maintenance’ phase is handing it over to the client (in the case of this project, that is handing it over to the professor to grade), receive feedback, and modify the program to improve based on the client’s needs. This process is really no different from the process I take in other classes and projects, its simply the tools and integrations I used that differ. 

For future applications of databases, I would like to incorporate more data validation, and optimize the way queries are made and data is retrieved to improve site performance. A lot of the queries took a long time to load, so there is surely room for improvement in that area. 

Computer scientists are at their core problem solvers. They innovate solutions related to data analysis, software security, and automation. This is important because these types of work can improve efficiency of software which reduces downtime and, in the world of business, time savings is also money savings. Computer scientists can create applications like this which promote visibility and accessibility of data, which can help individuals and organizations make better-informed decisions faster. Finally, computer scientists can improve scalability by creating programs such as this one, which can be used across multiple sites to aggregate business data into a single location. If Grazioso Salvare opens another location, they can easily  replicate what has already been built at other sites for their new location.
